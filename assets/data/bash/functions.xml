<?xml version="1.0" encoding="UTF-8"?>
<data>
  <topic name="functions">
    <title value="Functions on bash" />
    <!-- <docLink value="https://www.w3schools.com/tags/tag_title.asp" /> -->
    <description>
      <![CDATA[
Functions on python
      ]]>
    </description>
    <concept name="functions">
      <title value="Functions" />
      <docLink value="https://www.shellscript.sh/functions.html" />
      <description>
        <![CDATA[
One often-overlooked feature of Bourne shell script programming is that you can easily write functions for use within your script. This is generally done in one of two ways; 
with a simple script, the function is simply declared in the same file as it is called.
However, when writing a suite of scripts, it is often easier to write a "library" of useful functions, 
and source that file at the start of the other scripts which use the functions.<br>

There could be some confusion about whether to call shell functions procedures or functions; the definition of a function is traditionally that it returns a single value, 
and does not output anything. A procedure, on the other hand, does not return a value, but may produce output. A shell function may do neither, either or both. 
It is generally accepted that in shell scripts they are called functions.<br>

A function may return a value in one of four different ways:
<ul>
  <li>Change the state of a variable or variables</li>
  <li>Use the <code>exit</code> command to end the shell script</li>
  <li>Use the <code>return</code> command to end the function, and return the supplied value to the calling section of the shell script</li>
  <li><strong>echo output to stdout</strong>, which will be caught by the caller just as <code>c=&grave;expr $a + $b&grave;</code> is caught</li>
</ul>

This is rather like C, in that <code>exit</code> stops the program, and <code>return</code> returns control to the caller. The difference is that a shell function cannot change its parameters, 
though it can change global parameters.
        ]]>
      </description>
      <code language="bash">
        <![CDATA[
#!/bin/sh
# A simple script with a function...

add_a_user()
{
  USER=$1
  PASSWORD=$2
  shift; shift;
  # Having shifted twice, the rest is now comments ...
  COMMENTS=$@
  echo "Adding user $USER ..."
  echo useradd -c "$COMMENTS" $USER
  echo passwd $USER $PASSWORD
  echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
}

###
# Main body of script starts here
###
echo "Start of script..."
add_a_user bob letmein Bob Holness the presenter
add_a_user fred badpassword Fred Durst the singer
add_a_user bilko worsepassword Sgt. Bilko the role model
echo "End of script..."
        ]]>
      </code>
    </concept>
    <concept name="scope-of-variables">
      <title value="Scope of Variables" />
      <docLink value="https://www.shellscript.sh/functions.html" />
      <description>
        <![CDATA[
Programmers used to other languages may be surprised at the scope rules for shell functions. Basically, there is no scoping, other than the parameters 
(<code>$1</code>, <code>$2</code>, <code>$@</code>, etc).
        ]]>
      </description>
      <code language="bash">
        <![CDATA[
#!/bin/sh

myfunc()
{
  echo "I was called as : $@"
  x=2
}

### Main script starts here 

echo "Script was called with $@"
x=1
echo "x is $x"
myfunc 1 2 3
echo "x is $x"
        ]]>
      </code>
      <code language="bash">
        <![CDATA[
$ scope.sh a b c

Script was called with a b c
x is 1
I was called as : 1 2 3
x is 2

# The $@ parameters are changed within the function to reflect how the function was called
# The variable x, however, is effectively a global variable - myfunc changed it, 
# and that change is still effective when control returns to the main script
        ]]>
      </code>
    </concept>
    <concept name="recursion">
      <title value="Recursion" />
      <docLink value="https://www.shellscript.sh/functions.html" />
      <description>
        <![CDATA[
Functions can be recursive
        ]]>
      </description>
      <code language="bash">
        <![CDATA[
#!/bin/sh

factorial()
{
  if [ "$1" -gt "1" ]; then
    i=`expr $1 - 1`
    j=`factorial $i`
    k=`expr $1 \* $j`
    echo $k
  else
    echo 1
  fi
}


while :
do
  echo "Enter a number:"
  read x
  factorial $x
done  
        ]]>
      </code>
    </concept>
    <concept name="libraries">
      <title value="Libraries" />
      <docLink value="https://www.shellscript.sh/functions.html" />
      <description>
        <![CDATA[
It is also possible to use libraries between shell scripts
        ]]>
      </description>
      <code language="bash">
        <![CDATA[
# common.lib
# Note no #!/bin/sh as this should not spawn 
# an extra shell. It's not the end of the world 
# to have one, but clearer not to.
#
STD_MSG="About to rename some files..."

rename()
{
  # expects to be called as: rename .txt .bak 
  FROM=$1
  TO=$2

  for i in *$FROM
  do
    j=`basename $i $FROM`
    mv $i ${j}$TO
  done
}
        ]]>
      </code>
      <code language="bash">
        <![CDATA[
#!/bin/sh
# function2.sh
. ./common.lib
echo $STD_MSG
rename .txt .bak
        ]]>
      </code>
      <code language="bash">
        <![CDATA[
#!/bin/sh
# function3.sh
. ./common.lib
echo $STD_MSG
rename .html .html-bak
        ]]>
      </code>
    </concept>
    <concept name="return-codes">
      <title value="Return Codes" />
      <docLink value="https://www.shellscript.sh/functions.html" />
      <description>
        <![CDATA[
The return code can be used within a shell script to change the flow of execution depending on the success or failure of commands executed.<br>
Exit codes are a number between 0 and 255. <br>
Success is traditionally represented with <code>exit 0</code>; failure is normally indicated with a non-zero exit-code. This value can indicate different reasons for failure.
        ]]>
      </description>
      <code language="bash">
        <![CDATA[
#!/bin/sh

adduser()
{
  USER=$1
  PASSWORD=$2
  shift ; shift
  COMMENTS=$@
  useradd -c "${COMMENTS}" $USER
  if [ "$?" -ne "0" ]; then
    echo "Useradd failed"
    return 1
  fi
  passwd $USER $PASSWORD
  if [ "$?" -ne "0" ]; then
    echo "Setting password failed"
    return 2
  fi
  echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
}

## Main script starts here

adduser bob letmein Bob Holness from Blockbusters
ADDUSER_RETURN_CODE=$?
if [ "$ADDUSER_RETURN_CODE" -eq "1" ]; then
  echo "Something went wrong with useradd"
elif [ "$ADDUSER_RETURN_CODE" -eq "2" ]; then 
   echo "Something went wrong with passwd"
else
  echo "Bob Holness added to the system."
fi
        ]]>
      </code>
    </concept>
  </topic>
</data>